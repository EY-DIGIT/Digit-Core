{"version":3,"file":"index.cjs.production.min.js","sources":["../src/processRawValidationErrors.ts","../src/validator.ts","../src/customizeValidator.ts","../src/precompiledValidator.ts","../src/index.ts","../src/createPrecompiledValidator.ts"],"sourcesContent":["import { ErrorObject } from 'ajv';\nimport get from 'lodash/get';\nimport {\n  createErrorHandler,\n  CustomValidator,\n  ErrorTransformer,\n  FormContextType,\n  getDefaultFormState,\n  getUiOptions,\n  PROPERTIES_KEY,\n  RJSFSchema,\n  RJSFValidationError,\n  StrictRJSFSchema,\n  toErrorSchema,\n  UiSchema,\n  unwrapErrorHandler,\n  validationDataMerge,\n  ValidatorType,\n} from '@rjsf/utils';\n\nexport type RawValidationErrorsType<Result = any> = { errors?: Result[]; validationError?: Error };\n\n/** Transforming the error output from ajv to format used by @rjsf/utils.\n * At some point, components should be updated to support ajv.\n *\n * @param errors - The list of AJV errors to convert to `RJSFValidationErrors`\n * @param [uiSchema] - An optional uiSchema that is passed to `transformErrors` and `customValidate`\n */\nexport function transformRJSFValidationErrors<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(errors: ErrorObject[] = [], uiSchema?: UiSchema<T, S, F>): RJSFValidationError[] {\n  return errors.map((e: ErrorObject) => {\n    const { instancePath, keyword, params, schemaPath, parentSchema, ...rest } = e;\n    let { message = '' } = rest;\n    let property = instancePath.replace(/\\//g, '.');\n    let stack = `${property} ${message}`.trim();\n\n    if ('missingProperty' in params) {\n      property = property ? `${property}.${params.missingProperty}` : params.missingProperty;\n      const currentProperty: string = params.missingProperty;\n      const uiSchemaTitle = getUiOptions(get(uiSchema, `${property.replace(/^\\./, '')}`)).title;\n\n      if (uiSchemaTitle) {\n        message = message.replace(currentProperty, uiSchemaTitle);\n      } else {\n        const parentSchemaTitle = get(parentSchema, [PROPERTIES_KEY, currentProperty, 'title']);\n\n        if (parentSchemaTitle) {\n          message = message.replace(currentProperty, parentSchemaTitle);\n        }\n      }\n\n      stack = message;\n    } else {\n      const uiSchemaTitle = getUiOptions<T, S, F>(get(uiSchema, `${property.replace(/^\\./, '')}`)).title;\n\n      if (uiSchemaTitle) {\n        stack = `'${uiSchemaTitle}' ${message}`.trim();\n      } else {\n        const parentSchemaTitle = parentSchema?.title;\n\n        if (parentSchemaTitle) {\n          stack = `'${parentSchemaTitle}' ${message}`.trim();\n        }\n      }\n    }\n\n    // put data in expected format\n    return {\n      name: keyword,\n      property,\n      message,\n      params, // specific to ajv\n      stack,\n      schemaPath,\n    };\n  });\n}\n\n/** This function processes the `formData` with an optional user contributed `customValidate` function, which receives\n * the form data and a `errorHandler` function that will be used to add custom validation errors for each field. Also\n * supports a `transformErrors` function that will take the raw AJV validation errors, prior to custom validation and\n * transform them in what ever way it chooses.\n *\n * @param validator - The `ValidatorType` implementation used for the `getDefaultFormState()` call\n * @param rawErrors - The list of raw `ErrorObject`s to process\n * @param formData - The form data to validate\n * @param schema - The schema against which to validate the form data\n * @param [customValidate] - An optional function that is used to perform custom validation\n * @param [transformErrors] - An optional function that is used to transform errors after AJV validation\n * @param [uiSchema] - An optional uiSchema that is passed to `transformErrors` and `customValidate`\n */\nexport default function processRawValidationErrors<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  rawErrors: RawValidationErrorsType<ErrorObject>,\n  formData: T | undefined,\n  schema: S,\n  customValidate?: CustomValidator<T, S, F>,\n  transformErrors?: ErrorTransformer<T, S, F>,\n  uiSchema?: UiSchema<T, S, F>\n) {\n  const { validationError: invalidSchemaError } = rawErrors;\n  let errors = transformRJSFValidationErrors<T, S, F>(rawErrors.errors, uiSchema);\n\n  if (invalidSchemaError) {\n    errors = [...errors, { stack: invalidSchemaError!.message }];\n  }\n  if (typeof transformErrors === 'function') {\n    errors = transformErrors(errors, uiSchema);\n  }\n\n  let errorSchema = toErrorSchema<T>(errors);\n\n  if (invalidSchemaError) {\n    errorSchema = {\n      ...errorSchema,\n      $schema: {\n        __errors: [invalidSchemaError!.message],\n      },\n    };\n  }\n\n  if (typeof customValidate !== 'function') {\n    return { errors, errorSchema };\n  }\n\n  // Include form data with undefined values, which is required for custom validation.\n  const newFormData = getDefaultFormState<T, S, F>(validator, schema, formData, schema, true) as T;\n\n  const errorHandler = customValidate(newFormData, createErrorHandler<T>(newFormData), uiSchema);\n  const userErrorSchema = unwrapErrorHandler<T>(errorHandler);\n  return validationDataMerge<T>({ errors, errorSchema }, userErrorSchema);\n}\n","import Ajv, { ErrorObject, ValidateFunction } from 'ajv';\nimport {\n  CustomValidator,\n  ErrorSchema,\n  ErrorTransformer,\n  FormContextType,\n  ID_KEY,\n  RJSFSchema,\n  ROOT_SCHEMA_PREFIX,\n  StrictRJSFSchema,\n  toErrorList,\n  UiSchema,\n  ValidationData,\n  ValidatorType,\n  withIdRefPrefix,\n  hashForSchema,\n} from '@rjsf/utils';\n\nimport { CustomValidatorOptionsType, Localizer } from './types';\nimport createAjvInstance from './createAjvInstance';\nimport processRawValidationErrors, { RawValidationErrorsType } from './processRawValidationErrors';\n\n/** `ValidatorType` implementation that uses the AJV 8 validation mechanism.\n */\nexport default class AJV8Validator<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>\n  implements ValidatorType<T, S, F>\n{\n  /** The AJV instance to use for all validations\n   *\n   * @private\n   */\n  private ajv: Ajv;\n\n  /** The Localizer function to use for localizing Ajv errors\n   *\n   * @private\n   */\n  readonly localizer?: Localizer;\n\n  /** Constructs an `AJV8Validator` instance using the `options`\n   *\n   * @param options - The `CustomValidatorOptionsType` options that are used to create the AJV instance\n   * @param [localizer] - If provided, is used to localize a list of Ajv `ErrorObject`s\n   */\n  constructor(options: CustomValidatorOptionsType, localizer?: Localizer) {\n    const { additionalMetaSchemas, customFormats, ajvOptionsOverrides, ajvFormatOptions, AjvClass } = options;\n    this.ajv = createAjvInstance(additionalMetaSchemas, customFormats, ajvOptionsOverrides, ajvFormatOptions, AjvClass);\n    this.localizer = localizer;\n  }\n\n  /** Converts an `errorSchema` into a list of `RJSFValidationErrors`\n   *\n   * @param errorSchema - The `ErrorSchema` instance to convert\n   * @param [fieldPath=[]] - The current field path, defaults to [] if not specified\n   * @deprecated - Use the `toErrorList()` function provided by `@rjsf/utils` instead. This function will be removed in\n   *        the next major release.\n   */\n  toErrorList(errorSchema?: ErrorSchema<T>, fieldPath: string[] = []) {\n    return toErrorList(errorSchema, fieldPath);\n  }\n\n  /** Runs the pure validation of the `schema` and `formData` without any of the RJSF functionality. Provided for use\n   * by the playground. Returns the `errors` from the validation\n   *\n   * @param schema - The schema against which to validate the form data   * @param schema\n   * @param formData - The form data to validate\n   */\n  rawValidation<Result = any>(schema: S, formData?: T): RawValidationErrorsType<Result> {\n    let compilationError: Error | undefined = undefined;\n    let compiledValidator: ValidateFunction | undefined;\n    if (schema[ID_KEY]) {\n      compiledValidator = this.ajv.getSchema(schema[ID_KEY]);\n    }\n    try {\n      if (compiledValidator === undefined) {\n        compiledValidator = this.ajv.compile(schema);\n      }\n      compiledValidator(formData);\n    } catch (err) {\n      compilationError = err as Error;\n    }\n\n    let errors;\n    if (compiledValidator) {\n      if (typeof this.localizer === 'function') {\n        this.localizer(compiledValidator.errors);\n      }\n      errors = compiledValidator.errors || undefined;\n\n      // Clear errors to prevent persistent errors, see #1104\n      compiledValidator.errors = null;\n    }\n\n    return {\n      errors: errors as unknown as Result[],\n      validationError: compilationError,\n    };\n  }\n\n  /** This function processes the `formData` with an optional user contributed `customValidate` function, which receives\n   * the form data and a `errorHandler` function that will be used to add custom validation errors for each field. Also\n   * supports a `transformErrors` function that will take the raw AJV validation errors, prior to custom validation and\n   * transform them in what ever way it chooses.\n   *\n   * @param formData - The form data to validate\n   * @param schema - The schema against which to validate the form data\n   * @param [customValidate] - An optional function that is used to perform custom validation\n   * @param [transformErrors] - An optional function that is used to transform errors after AJV validation\n   * @param [uiSchema] - An optional uiSchema that is passed to `transformErrors` and `customValidate`\n   */\n  validateFormData(\n    formData: T | undefined,\n    schema: S,\n    customValidate?: CustomValidator<T, S, F>,\n    transformErrors?: ErrorTransformer<T, S, F>,\n    uiSchema?: UiSchema<T, S, F>\n  ): ValidationData<T> {\n    const rawErrors = this.rawValidation<ErrorObject>(schema, formData);\n    return processRawValidationErrors(this, rawErrors, formData, schema, customValidate, transformErrors, uiSchema);\n  }\n\n  /** Validates data against a schema, returning true if the data is valid, or\n   * false otherwise. If the schema is invalid, then this function will return\n   * false.\n   *\n   * @param schema - The schema against which to validate the form data\n   * @param formData - The form data to validate\n   * @param rootSchema - The root schema used to provide $ref resolutions\n   */\n  isValid(schema: S, formData: T | undefined, rootSchema: S) {\n    const rootSchemaId = rootSchema[ID_KEY] ?? ROOT_SCHEMA_PREFIX;\n    try {\n      // add the rootSchema ROOT_SCHEMA_PREFIX as id.\n      // then rewrite the schema ref's to point to the rootSchema\n      // this accounts for the case where schema have references to models\n      // that lives in the rootSchema but not in the schema in question.\n      if (this.ajv.getSchema(rootSchemaId) === undefined) {\n        this.ajv.addSchema(rootSchema, rootSchemaId);\n      }\n      const schemaWithIdRefPrefix = withIdRefPrefix<S>(schema) as S;\n      const schemaId = schemaWithIdRefPrefix[ID_KEY] ?? hashForSchema(schemaWithIdRefPrefix);\n      let compiledValidator: ValidateFunction | undefined;\n      compiledValidator = this.ajv.getSchema(schemaId);\n      if (compiledValidator === undefined) {\n        // Add schema by an explicit ID so it can be fetched later\n        // Fall back to using compile if necessary\n        // https://ajv.js.org/guide/managing-schemas.html#pre-adding-all-schemas-vs-adding-on-demand\n        compiledValidator =\n          this.ajv.addSchema(schemaWithIdRefPrefix, schemaId).getSchema(schemaId) ||\n          this.ajv.compile(schemaWithIdRefPrefix);\n      }\n      const result = compiledValidator(formData);\n      return result as boolean;\n    } catch (e) {\n      console.warn('Error encountered compiling schema:', e);\n      return false;\n    } finally {\n      // TODO: A function should be called if the root schema changes so we don't have to remove and recompile the schema every run.\n      // make sure we remove the rootSchema from the global ajv instance\n      this.ajv.removeSchema(rootSchemaId);\n    }\n  }\n}\n","import { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '@rjsf/utils';\n\nimport { CustomValidatorOptionsType, Localizer } from './types';\nimport AJV8Validator from './validator';\n\n/** Creates and returns a customized implementation of the `ValidatorType` with the given customization `options` if\n * provided. If a `localizer` is provided, it is used to translate the messages generated by the underlying AJV\n * validation.\n *\n * @param [options={}] - The `CustomValidatorOptionsType` options that are used to create the `ValidatorType` instance\n * @param [localizer] - If provided, is used to localize a list of Ajv `ErrorObject`s\n * @returns - The custom validator implementation resulting from the set of parameters provided\n */\nexport default function customizeValidator<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(options: CustomValidatorOptionsType = {}, localizer?: Localizer): ValidatorType<T, S, F> {\n  return new AJV8Validator<T, S, F>(options, localizer);\n}\n","import { ErrorObject } from 'ajv';\nimport get from 'lodash/get';\nimport isEqual from 'lodash/isEqual';\nimport {\n  CustomValidator,\n  ErrorSchema,\n  ErrorTransformer,\n  FormContextType,\n  hashForSchema,\n  ID_KEY,\n  JUNK_OPTION_ID,\n  RJSFSchema,\n  StrictRJSFSchema,\n  toErrorList,\n  UiSchema,\n  ValidationData,\n  ValidatorType,\n  retrieveSchema,\n} from '@rjsf/utils';\n\nimport { CompiledValidateFunction, Localizer, ValidatorFunctions } from './types';\nimport processRawValidationErrors, { RawValidationErrorsType } from './processRawValidationErrors';\n\n/** `ValidatorType` implementation that uses an AJV 8 precompiled validator as created by the\n * `compileSchemaValidators()` function provided by the `@rjsf/validator-ajv8` library.\n */\nexport default class AJV8PrecompiledValidator<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n> implements ValidatorType<T, S, F>\n{\n  /** The root schema object used to construct this validator\n   *\n   * @private\n   */\n  readonly rootSchema: S;\n\n  /** The root schema resolved top level refs\n   *\n   * @private\n   */\n  readonly resolvedRootSchema: S;\n\n  /** The `ValidatorFunctions` map used to construct this validator\n   *\n   * @private\n   */\n  readonly validateFns: ValidatorFunctions;\n\n  /** The main validator function associated with the base schema in the `precompiledValidator`\n   *\n   * @private\n   */\n  readonly mainValidator: CompiledValidateFunction;\n\n  /** The Localizer function to use for localizing Ajv errors\n   *\n   * @private\n   */\n  readonly localizer?: Localizer;\n\n  /** Constructs an `AJV8PrecompiledValidator` instance using the `validateFns` and `rootSchema`\n   *\n   * @param validateFns - The map of the validation functions that are generated by the `schemaCompile()` function\n   * @param rootSchema - The root schema that was used with the `compileSchema()` function\n   * @param [localizer] - If provided, is used to localize a list of Ajv `ErrorObject`s\n   * @throws - Error when the base schema of the precompiled validator does not have a matching validator function\n   */\n  constructor(validateFns: ValidatorFunctions, rootSchema: S, localizer?: Localizer) {\n    this.rootSchema = rootSchema;\n    this.validateFns = validateFns;\n    this.localizer = localizer;\n    this.mainValidator = this.getValidator(rootSchema);\n    this.resolvedRootSchema = retrieveSchema(this, rootSchema, rootSchema);\n  }\n\n  /** Returns the precompiled validator associated with the given `schema` from the map of precompiled validator\n   * functions.\n   *\n   * @param schema - The schema for which a precompiled validator function is desired\n   * @returns - The precompiled validator function associated with this schema\n   */\n  getValidator(schema: S) {\n    const key = get(schema, ID_KEY) || hashForSchema(schema);\n    const validator = this.validateFns[key];\n    if (!validator) {\n      throw new Error(`No precompiled validator function was found for the given schema for \"${key}\"`);\n    }\n    return validator;\n  }\n\n  /** Converts an `errorSchema` into a list of `RJSFValidationErrors`\n   *\n   * @param errorSchema - The `ErrorSchema` instance to convert\n   * @param [fieldPath=[]] - The current field path, defaults to [] if not specified\n   * @deprecated - Use the `toErrorList()` function provided by `@rjsf/utils` instead. This function will be removed in\n   *        the next major release.\n   */\n  toErrorList(errorSchema?: ErrorSchema<T>, fieldPath: string[] = []) {\n    return toErrorList(errorSchema, fieldPath);\n  }\n\n  /** Runs the pure validation of the `schema` and `formData` without any of the RJSF functionality. Provided for use\n   * by the playground. Returns the `errors` from the validation\n   *\n   * @param schema - The schema against which to validate the form data   * @param schema\n   * @param formData - The form data to validate\n   * @throws - Error when the schema provided does not match the base schema of the precompiled validator\n   */\n  rawValidation<Result = any>(schema: S, formData?: T): RawValidationErrorsType<Result> {\n    if (!isEqual(schema, this.resolvedRootSchema)) {\n      throw new Error(\n        'The schema associated with the precompiled schema differs from the schema provided for validation'\n      );\n    }\n    this.mainValidator(formData);\n\n    if (typeof this.localizer === 'function') {\n      this.localizer(this.mainValidator.errors);\n    }\n    const errors = this.mainValidator.errors || undefined;\n\n    // Clear errors to prevent persistent errors, see #1104\n    this.mainValidator.errors = null;\n\n    return { errors: errors as unknown as Result[] };\n  }\n\n  /** This function processes the `formData` with an optional user contributed `customValidate` function, which receives\n   * the form data and a `errorHandler` function that will be used to add custom validation errors for each field. Also\n   * supports a `transformErrors` function that will take the raw AJV validation errors, prior to custom validation and\n   * transform them in what ever way it chooses.\n   *\n   * @param formData - The form data to validate\n   * @param schema - The schema against which to validate the form data\n   * @param [customValidate] - An optional function that is used to perform custom validation\n   * @param [transformErrors] - An optional function that is used to transform errors after AJV validation\n   * @param [uiSchema] - An optional uiSchema that is passed to `transformErrors` and `customValidate`\n   */\n  validateFormData(\n    formData: T | undefined,\n    schema: S,\n    customValidate?: CustomValidator<T, S, F>,\n    transformErrors?: ErrorTransformer<T, S, F>,\n    uiSchema?: UiSchema<T, S, F>\n  ): ValidationData<T> {\n    const rawErrors = this.rawValidation<ErrorObject>(schema, formData);\n    return processRawValidationErrors(this, rawErrors, formData, schema, customValidate, transformErrors, uiSchema);\n  }\n\n  /** Validates data against a schema, returning true if the data is valid, or false otherwise. If the schema is\n   * invalid, then this function will return false.\n   *\n   * @param schema - The schema against which to validate the form data\n   * @param formData - The form data to validate\n   * @param rootSchema - The root schema used to provide $ref resolutions\n   * @returns - true if the formData validates against the schema, false otherwise\n   * @throws - Error when the schema provided does not match the base schema of the precompiled validator OR if there\n   *        isn't a precompiled validator function associated with the schema\n   */\n  isValid(schema: S, formData: T | undefined, rootSchema: S) {\n    if (!isEqual(rootSchema, this.rootSchema)) {\n      throw new Error(\n        'The schema associated with the precompiled validator differs from the rootSchema provided for validation'\n      );\n    }\n    if (get(schema, ID_KEY) === JUNK_OPTION_ID) {\n      return false;\n    }\n    const validator = this.getValidator(schema);\n    return validator(formData);\n  }\n}\n","import customizeValidator from './customizeValidator';\nimport createPrecompiledValidator from './createPrecompiledValidator';\n\nexport { customizeValidator, createPrecompiledValidator };\nexport * from './types';\n\nexport default customizeValidator();\n","import { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '@rjsf/utils';\n\nimport { Localizer, ValidatorFunctions } from './types';\nimport AJV8PrecompiledValidator from './precompiledValidator';\n\n/** Creates and returns a `ValidatorType` interface that is implemented with a precompiled validator. If a `localizer`\n * is provided, it is used to translate the messages generated by the underlying AJV validation.\n *\n * NOTE: The `validateFns` parameter is an object obtained by importing from a precompiled validation file created via\n * the `compileSchemaValidators()` function.\n *\n * @param validateFns - The map of the validation functions that are created by the `compileSchemaValidators()` function\n * @param rootSchema - The root schema that was used with the `compileSchemaValidators()` function\n * @param [localizer] - If provided, is used to localize a list of Ajv `ErrorObject`s\n * @returns - The precompiled validator implementation resulting from the set of parameters provided\n */\nexport default function createPrecompiledValidator<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(validateFns: ValidatorFunctions, rootSchema: S, localizer?: Localizer): ValidatorType<T, S, F> {\n  return new AJV8PrecompiledValidator<T, S, F>(validateFns, rootSchema, localizer);\n}\n"],"names":["processRawValidationErrors","validator","rawErrors","formData","schema","customValidate","transformErrors","uiSchema","invalidSchemaError","validationError","errors","map","e","instancePath","keyword","params","schemaPath","parentSchema","_rest$message","_objectWithoutPropertiesLoose","_excluded","message","property","replace","stack","trim","currentProperty","missingProperty","uiSchemaTitle","getUiOptions","get","title","parentSchemaTitle","PROPERTIES_KEY","name","transformRJSFValidationErrors","concat","errorSchema","toErrorSchema","_extends","$schema","__errors","newFormData","getDefaultFormState","errorHandler","createErrorHandler","userErrorSchema","unwrapErrorHandler","validationDataMerge","AJV8Validator","options","localizer","this","ajv","createAjvInstance","additionalMetaSchemas","customFormats","ajvOptionsOverrides","ajvFormatOptions","AjvClass","_proto","prototype","toErrorList","fieldPath","rawValidation","compiledValidator","compilationError","undefined","ID_KEY","getSchema","compile","err","validateFormData","isValid","rootSchema","_rootSchema$ID_KEY","rootSchemaId","ROOT_SCHEMA_PREFIX","_schemaWithIdRefPrefi","addSchema","schemaWithIdRefPrefix","withIdRefPrefix","schemaId","hashForSchema","console","warn","removeSchema","customizeValidator","AJV8PrecompiledValidator","validateFns","resolvedRootSchema","mainValidator","getValidator","retrieveSchema","key","Error","isEqual","JUNK_OPTION_ID"],"mappings":"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"}